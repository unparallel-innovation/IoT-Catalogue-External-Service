<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>
const EventEmmiter = require("events")
const ws = require("ws");
const SimpleDDP = require("simpleddp");
const crypto = require("crypto");
const axios = require('axios').default;
const log4js = require("log4js");
const logger = log4js.getLogger();
logger.level = "debug";
const simpleDDPLogin = require("simpleddp-plugin-login").simpleDDPLogin;

/**
 * Establishes a connection with IoT Catalogue, allows a real time subscription with IoT Catalogue and to the dataset authenticated for the user
 * @extends EventEmmiter
 */
class Connection extends EventEmmiter{

    /**
     * Props related with data subscription
     * @typedef {Object} connectionProps
     * @property {object} dataFields - Fields that must be returned from the data subscription
     */


    /**
     *
     * @param {String} socketAddress  Web socket address to IoT Catalogue instance
     * @param {String} token Token used to authenticate the user
     * @param {Object} serviceDescription Object describing the features of the external service
     * @param {connectionProps} connectionProps Props related with data subscription
     */
    constructor(socketAddress, token,  serviceDescription, connectionProps) {
        super();
        this.socketAddress = socketAddress
        this.socketAddressURL = new URL(this.socketAddress)
        this.token = token
        this.serviceDescription = serviceDescription
        this.connectionProps = connectionProps
        this.collectionHandlers = []
        this.collectionSubscription = []
        this.pingInterval = 3
        this.timeout = 60
        if(! this.socketAddress){
            throw {"err":"Missing socketAddress"}
        }

        if(!this.token){
            throw {err:"Missing token"}
        }

        const opts = {
            endpoint:  this.socketAddress + "/websocket",
            SocketConstructor: ws,
            reconnectInterval: 5000
        };


        this.ddpConnection = new SimpleDDP(opts,[simpleDDPLogin])
        this.ddpConnection.on("connected",async (info)=>{
            logger.info("Connected to " +  this.socketAddress);
            this.remoteUpSince = new Date((await this.ping()).upSince)
            try{
                await this.ddpConnection.login({userToken:this.hashUserToken()})
                await this.getConnectionService()
                await this.subscribeToExternalServiceCommunication()
                await this.subscribeToData()
                this.schedulePing()
            }catch(err){
                console.error("ERR", err)
                this.ddpConnection.disconnect();
            }
        })


        this.ddpConnection.on('disconnected', () => {
            clearInterval(this.setIntervalId)
            for(const collectionHandler of this.collectionHandlers){
                collectionHandler.stop()
            }
            this.collectionHandlers = []
            if(this.actionSub){
                this.actionSub.remove()
                this.actionSub = null;
            }
            for(const collectionSubscription of this.collectionSubscription){
                collectionSubscription.remove()
            }
            this.collectionSubscription = []
            logger.info("Disconnected from " +  this.socketAddress)

        });






    }

    tryToReconnect(){
        this.ddpConnection.disconnect();
        this.ddpConnection.connect()
    }


    async ping(){
        const protocol = (this.socketAddressURL.protocol === "wss:" || this.socketAddressURL.protocol === "https:")?"https:":"http:"
        const pingURL = protocol  +"//" + this.socketAddressURL.host + "/status"

        const res = await axios.get(pingURL,{timeout:this.timeout*1000})
        return res.data
    }

    async schedulePing(){

        this.setIntervalId = setInterval(async ()=>{


            try{

                const data = await this.ping()

                if(data?.value!=="up" ){
                    logger.error("Ping failed reconnecting")
                    this.tryToReconnect()
                }else{

                    const connectionTime = this.remoteUpSince.getTime()
                    const currentTime = new Date(data.upSince).getTime()
                    if(currentTime > connectionTime ){
                        logger.error("Ping failed reconnecting")
                        this.tryToReconnect()
                    }
                }
            }catch(err){
                logger.error("Ping failed reconnecting")
                this.tryToReconnect()
            }
        },this.pingInterval*1000)


    }

    observeCollection(collectionName, onChange){
        const collection = this.ddpConnection.collection(collectionName)
        const collectionHandler = collection.onChange((obj)=>{
            if(typeof onChange == "function"){
                onChange( collectionName, obj)
            }
        })
        this.collectionHandlers.push(collectionHandler)
    }

    observeActions(){
        const onChange = async (collectionName, obj)=>{

            const actions = []
            if (obj.added) {
                actions.push("added")
                if(obj.added.state === "added"){
                    this.emit("actionAdded",
                        obj.added,
                        (result, error)=>{
                            this.actionCallback(obj.added, result, error)
                        }
                    )
                }

            }
            if(obj.changed) {
                actions.push("changed")

            }
            if(obj.removed) {
                actions.push("removed")
            }



        }
        this.observeCollection("externalServiceCommunication",onChange)
    }


    async subscribeToData(){
        const collectionNames = await this.ddpConnection.call("getUserDataCollectionNames")
        for(const collectionName of collectionNames){

            this.observeCollection(collectionName,(collectionName, obj)=>{
                this.emit("dataChange",collectionName, {
                    changed:this.fixIdFromObject(obj.changed),
                    added:this.fixIdFromObject(obj.added),
                    removed:this.fixIdFromObject(obj.removed)
                })
            })
            await this.subscribeToCollection(collectionName)
        }

    }
    async subscribeToCollection(collectionName){
        const fields = this.connectionProps?.dataFields || this.connectionProps?.fields

        const sub = this.ddpConnection.subscribe("subscribeToServiceData",collectionName, {fields})
        await sub.ready()
        this.collectionSubscription.push(sub)
    }

    async subscribeToExternalServiceCommunication(){
        this.observeActions()
        this.actionSub = this.ddpConnection.subscribe("subscribeToExternalServiceCommunication")


        await this.actionSub.ready()
    }


    actionCallback(obj, result, error){

        this.ddpConnection.call("actionCallback",obj.id, result, error)



    }

    async getConnectionService(){
        const connectionService = await this.ddpConnection.call("getConnectionService", this.serviceDescription)
        if(connectionService.serviceFound === true){
            this.emit("subscribedToService",connectionService)
        }
    }

    hashUserToken(){
        const hash = crypto.createHash('sha256');
        hash.update(this.token);
        return {
            digest: hash.digest('base64'),
            algorithm: "sha-256"
        }
    }


    /**
    * Attach an event handler function for the connection
    *
    * possible events are:&lt;br>
    * &lt;ul>
    *   &lt;li>connected&lt;/li>
    *   &lt;li>disconnected&lt;/li>
     *   &lt;li>actionAdded&lt;/li>
     *   &lt;li>dataChange&lt;/li>
     *   &lt;li>subscribedToService&lt;/li>
    * &lt;/ul>
    *@param {string} event - Name of the event
    * @param {function} callback - Callback for the event
    **/
    on(event, callback){
        if(event === "disconnected" || event ==="connected"){
            return this.ddpConnection.on(event,callback)
        }
        return super.on(event, callback)
    }



    /**
     *
     * Notify the external app when actions are added, the reply is given through a callback
     *
     *
     * @param {actionAddedCallback} callback Callback that handles actionAdded
     */
    onActionAdded(callback){
       return this.on("actionAdded",callback)
    }

    /**
     * @callback actionAddedCallback
     * @param {object} action object describing the action
     * @param {function} callback used to reply to the action
     */


    /**

     * @param {dataChangeCallback} callback Callback to process data change
     */
    onDataChange(callback){
        return this.on("dataChange",callback)
    }

    /**
     * @callback dataChangeCallback
     * @param {string} collectionName Name of the collection
     * @param {function} obj object representing the data added
     */


    /**
     *
     * @param {subscribedToServiceCallback}
     */
    onSubscribedToService(callback){
        return this.on("subscribedToService",callback)
    }

    /**
     * @callback subscribedToServiceCallback
     * @param {object} serviceInfo Description of the service and its properties
     */


    /**
     * Attach an event handler function when a connection is established
     * @param {function} callback - Callback which receives new data from the subscription
     *
     */
    onConnected(callback){
        return this.on("connected",callback)
    }

    /**
     * Attach an event handler function when a connection is finished
     * @param {function} callback - Callback which receives new data from the subscription
     *
     */
    onDisconnected(callback){
        return this.on("disconnected",callback)
    }

    /**
     * Call a function from meteor.
     *
     */
    call(){
        return this.ddpConnection.call(...arguments)
    }

    fixIdFromObject(obj){

        if(typeof obj == "object" &amp;&amp; obj.id.length === 25 &amp;&amp; obj.id.startsWith("-") &amp;&amp; /[0-9A-Fa-f]{24}/g.test(obj.id)){
            const id = obj.id.substring(1,obj.id.length)
            return {...obj,id}
        }


        return obj
    }



}

exports.Connection = Connection

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Connection.html">Connection</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Mon Oct 25 2021 17:30:19 GMT+0100 (Western European Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
